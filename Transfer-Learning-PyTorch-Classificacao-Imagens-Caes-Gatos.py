# -*- coding: utf-8 -*-
"""Transfer_Learning_DIO_Fabio_Chimanski

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gcCoEnJQhQCS4n9YAPwr--Gqx1F8bOh4

# Importando bibliotecas
import torch	Importa o PyTorch, a principal biblioteca de redes neurais

import torchvision	Cont√©m datasets, modelos prontos e ferramentas para vis√£o computacional

import torchvision.transforms as transforms	Serve para transformar e preparar imagens (ex: redimensionar, normalizar etc.)

import torch.nn as nn	Cont√©m as camadas de redes neurais (ex: Linear, ReLU, etc.)

import torch.optim as optim	Algoritmos de otimiza√ß√£o, como o SGD ou Adam

import torchvision.models as models	Cont√©m modelos famosos j√° treinados, como ResNet, AlexNet, VGG etc.
"""

import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.optim as optim
import torchvision.models as models

"""# Carregando modelo pr√©-treinado(ResNet18)
O modelo ResNet18 √© uma rede neural j√° treinada com milh√µes de imagens (no banco ImageNet). Vamos carregar esse modelo para usar o que ele j√° aprendeu.

models.resnet18(pretrained=True) ‚Üí Carrega a arquitetura da ResNet18 com pesos j√° treinados.

Esse modelo j√° sabe reconhecer milhares de objetos em imagens (gato, cachorro, carro...).

Vamos usar esse ‚Äúconhecimento‚Äù dele para treinar algo novo com menos dados.
"""

# Carregar o modelo ResNet18 pr√©-treinado
model = models.resnet18(pretrained=True)

# Ver a estrutura do modelo (opcional)
print(model)

"""# Agora vamos -->

Congelar as camadas antigas (para n√£o ‚Äúesquecer‚Äù o que j√° aprendeu).

Trocar a √∫ltima camada (fully connected) para classificar apenas 2 categorias.
"""

# Congelar todas as camadas antigas (evita que elas sejam atualizadas durante o treino)
for param in model.parameters():
    param.requires_grad = False

# Substituir a √∫ltima camada (fc = fully connected) por uma nova que classifica 2 classes
num_ftrs = model.fc.in_features
model.fc = nn.Linear(num_ftrs, 2)  # Agora temos s√≥ duas sa√≠das: gato e carro

"""# Carregar as imagens com o ImageFolder do PyTorch

A gente s√≥ precisa aplicar transforma√ß√µes (como redimensionar e normalizar as imagens) e montar os DataLoaders
"""

#Descomparctar data.zip
import zipfile
import os

zip_path = '/content/data.zip'
extract_path = '/content/data'

# Descompactar o zip
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

# Verificar estrutura
for root, dirs, files in os.walk(extract_path):
    print(f'üìÅ {root} - {len(files)} arquivos')

from torchvision import datasets, transforms
from torch.utils.data import DataLoader

# Transforma√ß√µes para as imagens (ex: redimensionar e normalizar)
transform = transforms.Compose([
    transforms.Resize((224, 224)),  # Tamanho esperado pela ResNet18
    transforms.ToTensor(),          # Converte imagem em tensor
    transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])  # Normaliza RGB
])

# Caminhos das pastas
train_path = '/content/data/data/train'
val_path = '/content/data/data/val'


# Carregar datasets
train_dataset = datasets.ImageFolder(train_path, transform=transform)
val_dataset = datasets.ImageFolder(val_path, transform=transform)

# Criar DataLoaders (batch = grupo de imagens)
train_loader = DataLoader(train_dataset, batch_size=16, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=16, shuffle=False)

# Verificar classes
print(f'Classes detectadas: {train_dataset.classes}')

"""#Treinar o modelo para classificar gato e cachorro


"""

import torch.nn as nn
import torch.optim as optim
import torch

# Usar GPU se dispon√≠vel
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)

# Fun√ß√£o de custo (qu√£o errado o modelo est√°)
criterion = nn.CrossEntropyLoss()

# Otimizador (como o modelo vai aprender)
optimizer = optim.Adam(model.fc.parameters(), lr=0.001)

# N√∫mero de √©pocas (quantas vezes passar pelo dataset)
epochs = 15

for epoch in range(epochs):
    model.train()
    running_loss = 0.0

    for images, labels in train_loader:
        images, labels = images.to(device), labels.to(device)

        optimizer.zero_grad()             # Zera os gradientes anteriores
        outputs = model(images)           # Faz a previs√£o
        loss = criterion(outputs, labels) # Calcula o erro
        loss.backward()                   # Calcula os gradientes
        optimizer.step()                  # Atualiza os pesos

        running_loss += loss.item()

    print(f"√âpoca {epoch+1}/{epochs} - Loss: {running_loss:.4f}")

"""#Teste de imagem"""

from PIL import Image
import matplotlib.pyplot as plt

def prever_imagem(caminho_imagem):
    # Abrir imagem e aplicar as mesmas transforma√ß√µes do treino
    imagem = Image.open(caminho_imagem).convert('RGB')
    transformada = transform(imagem).unsqueeze(0).to(device)  # Adiciona dimens√£o do batch

    model.eval()
    with torch.no_grad():
        saida = model(transformada)
        _, predicao = torch.max(saida, 1)

    # Mostrar resultado
    classe = train_dataset.classes[predicao.item()]
    plt.imshow(imagem)
    plt.title(f"Predi√ß√£o: {classe}")
    plt.axis('off')
    plt.show()

# Exemplo: prever imagem que voc√™ subiu
prever_imagem("/content/421.jpg")  # Troque pelo nome real do seu arquivo