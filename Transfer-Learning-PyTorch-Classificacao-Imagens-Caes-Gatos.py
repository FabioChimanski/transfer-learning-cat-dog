# -*- coding: utf-8 -*-
"""Transfer_Learning_DIO_Fabio_Chimanski

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gcCoEnJQhQCS4n9YAPwr--Gqx1F8bOh4

# Importando bibliotecas
import torch	Importa o PyTorch, a principal biblioteca de redes neurais

import torchvision	Contém datasets, modelos prontos e ferramentas para visão computacional

import torchvision.transforms as transforms	Serve para transformar e preparar imagens (ex: redimensionar, normalizar etc.)

import torch.nn as nn	Contém as camadas de redes neurais (ex: Linear, ReLU, etc.)

import torch.optim as optim	Algoritmos de otimização, como o SGD ou Adam

import torchvision.models as models	Contém modelos famosos já treinados, como ResNet, AlexNet, VGG etc.
"""

import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.optim as optim
import torchvision.models as models

"""# Carregando modelo pré-treinado(ResNet18)
O modelo ResNet18 é uma rede neural já treinada com milhões de imagens (no banco ImageNet). Vamos carregar esse modelo para usar o que ele já aprendeu.

models.resnet18(pretrained=True) → Carrega a arquitetura da ResNet18 com pesos já treinados.

Esse modelo já sabe reconhecer milhares de objetos em imagens (gato, cachorro, carro...).

Vamos usar esse “conhecimento” dele para treinar algo novo com menos dados.
"""

# Carregar o modelo ResNet18 pré-treinado
model = models.resnet18(pretrained=True)

# Ver a estrutura do modelo (opcional)
print(model)

"""# Agora vamos -->

Congelar as camadas antigas (para não “esquecer” o que já aprendeu).

Trocar a última camada (fully connected) para classificar apenas 2 categorias.
"""

# Congelar todas as camadas antigas (evita que elas sejam atualizadas durante o treino)
for param in model.parameters():
    param.requires_grad = False

# Substituir a última camada (fc = fully connected) por uma nova que classifica 2 classes
num_ftrs = model.fc.in_features
model.fc = nn.Linear(num_ftrs, 2)  # Agora temos só duas saídas: gato e carro

"""# Carregar as imagens com o ImageFolder do PyTorch

A gente só precisa aplicar transformações (como redimensionar e normalizar as imagens) e montar os DataLoaders
"""

#Descomparctar data.zip
import zipfile
import os

zip_path = '/content/data.zip'
extract_path = '/content/data'

# Descompactar o zip
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

# Verificar estrutura
for root, dirs, files in os.walk(extract_path):
    print(f' {root} - {len(files)} arquivos')

from torchvision import datasets, transforms
from torch.utils.data import DataLoader

# Transformações para as imagens (ex: redimensionar e normalizar)
transform = transforms.Compose([
    transforms.Resize((224, 224)),  # Tamanho esperado pela ResNet18
    transforms.ToTensor(),          # Converte imagem em tensor
    transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])  # Normaliza RGB
])

# Caminhos das pastas
train_path = '/content/data/data/train'
val_path = '/content/data/data/val'


# Carregar datasets
train_dataset = datasets.ImageFolder(train_path, transform=transform)
val_dataset = datasets.ImageFolder(val_path, transform=transform)

# Criar DataLoaders (batch = grupo de imagens)
train_loader = DataLoader(train_dataset, batch_size=16, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=16, shuffle=False)

# Verificar classes
print(f'Classes detectadas: {train_dataset.classes}')

"""#Treinar o modelo para classificar gato e cachorro


"""

import torch.nn as nn
import torch.optim as optim
import torch

# Usar GPU se disponível
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)

# Função de custo (quão errado o modelo está)
criterion = nn.CrossEntropyLoss()

# Otimizador (como o modelo vai aprender)
optimizer = optim.Adam(model.fc.parameters(), lr=0.001)

# Número de épocas (quantas vezes passar pelo dataset)
epochs = 15

for epoch in range(epochs):
    model.train()
    running_loss = 0.0

    for images, labels in train_loader:
        images, labels = images.to(device), labels.to(device)

        optimizer.zero_grad()             # Zera os gradientes anteriores
        outputs = model(images)           # Faz a previsão
        loss = criterion(outputs, labels) # Calcula o erro
        loss.backward()                   # Calcula os gradientes
        optimizer.step()                  # Atualiza os pesos

        running_loss += loss.item()

    print(f"Época {epoch+1}/{epochs} - Loss: {running_loss:.4f}")

"""#Teste de imagem"""

from PIL import Image
import matplotlib.pyplot as plt

def prever_imagem(caminho_imagem):
    # Abrir imagem e aplicar as mesmas transformações do treino
    imagem = Image.open(caminho_imagem).convert('RGB')
    transformada = transform(imagem).unsqueeze(0).to(device)  # Adiciona dimensão do batch

    model.eval()
    with torch.no_grad():
        saida = model(transformada)
        _, predicao = torch.max(saida, 1)

    # Mostrar resultado
    classe = train_dataset.classes[predicao.item()]
    plt.imshow(imagem)
    plt.title(f"Predição: {classe}")
    plt.axis('off')
    plt.show()

# Exemplo: prever imagem que você subiu
prever_imagem("/content/421.jpg")  # Troque pelo nome real do seu arquivo